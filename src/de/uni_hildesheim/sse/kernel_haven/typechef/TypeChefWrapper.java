package de.uni_hildesheim.sse.kernel_haven.typechef;

import java.io.EOFException;
import java.io.File;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.ProcessBuilder.Redirect;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import de.uni_hildesheim.sse.kernel_haven.code_model.SourceFile;
import de.uni_hildesheim.sse.kernel_haven.util.Logger;

public class TypeChefWrapper {

    private static final Logger LOGGER = Logger.get();
    
    /**
     * Whether to launch a separate JVM or not. Set to <code>true</code> only
     * for debug purposes.
     */
    private static final boolean CALL_IN_SAME_VM = true;
    
    /**
     * Whether the TypeChef parameters should be logged.
     */
    private static final boolean LOG_CALL_PARAMS = true;
    
    /**
     * Whether the child JVM process should have same stdout and stderr as the parent one.
     */
    private static final boolean INHERIT_OUTPUT = true;
    
    private File sourceDir;
    
    private File platformHeader;
    
    private File openVariablesFile;
    
    private File systemRoot;
    
    private List<File> staticIncludes;
    
    private List<File> postIncludeDirs;
    
    private List<File> sourceIncludeDirs;
    
    private List<String> preprocessorDefines;
    
//    private KbuildParamFile kbuildParamFile;
    
    private File dimacsModel;
    
//    private File workingDir;
    
    /**
     * Creates a {@link TypeChef} instance with no parameters set. The appropriate
     * set* and add* methods must be called before this can be used.
     */
    public TypeChefWrapper() {
        staticIncludes = new ArrayList<>();
        postIncludeDirs = new ArrayList<>();
        sourceIncludeDirs = new ArrayList<>();
        preprocessorDefines = new ArrayList<>();
    }
    

    /**
     * Sets the path to the source code tree.
     * 
     * @param sourceDir The directory of the source code tree.
     */
    public void setSourceDir(File sourceDir) {
        this.sourceDir = sourceDir;
    }

    /**
     * Sets the path to the platform header file, containing the symbols defined
     * by the compiler, that will be included at the top of the source file.
     * 
     * @param platformHeader The platform header file.
     */
    public void setPlatformHeader(File platformHeader) {
        this.platformHeader = platformHeader;
    }
    
    
    /**
     * Sets the path to a file listing all (open, i.e. not permanently true or false)
     * Kconfig variables. This file is usually generated by KbuildMiner.
     * This is optional, but using this file helps reduce the complexity of the
     * presence conditions, because variables that are always true or always
     * false can be filtered out. If this file is not provided, then all CONFIG_
     * variables are treated as variability.
     * 
     * @param openVariablesFile The file containing a list of variable names
     *      (with CONFIG_ prefix, one name per line).
     */
    public void setOpenVariablesFile(File openVariablesFile) {
        this.openVariablesFile = openVariablesFile;
    }
    
    /**
     * Sets the system root root directory. System include directories are
     * interpreted to be relative to this. There should at least be a
     * <code>usr/include/</code> folder in this system root. Most Linux machines
     * probably want to use simply <code>/</code> here.
     * 
     * @param systemRoot The system root directory, where all system include directories are located.
     */
    public void setSystemRoot(File systemRoot) {
        this.systemRoot = systemRoot;
    }
    
    /**
     * Adds a header file that is always included at the top of source files.
     * This can be used for overriding headers (by defining their include guard),
     * or adding other definitions, that should always be present while parsing.
     * 
     * @param staticInclude The header file that is statically included, before
     *      anything else in the source file.
     */
    public void addStaticInclude(File staticInclude) {
        staticIncludes.add(staticInclude);
    }
    
    /**
     * Clears the list of system include directories.
     */
    public void clearStaticInclude() {
        staticIncludes.clear();
    }
    
    /**
     * Adds a system include directory, where TypeChef will search for header files.
     * 
     * @param postIncludeDir The system include directory, relative to the system root.
     */
    public void addPostIncludeDir(File postIncludeDir) {
        postIncludeDirs.add(postIncludeDir);
    }
    
    /**
     * Adds the default list of system include directories. This works for the
     * headers of an Ubuntu machine.
     */
    public void addDefaultPostIncludeDirs() {
        addPostIncludeDir(new File("usr/lib/gcc/x86_64-linux-gnu/5/include"));
        addPostIncludeDir(new File("usr/include/x86_64-linux-gnu"));
        addPostIncludeDir(new File("usr/include"));
    }
    
    /**
     * Clears the list of system include directories.
     */
    public void clearPostIncludeDirs() {
        postIncludeDirs.clear();
    }
    
    /**
     * Adds an include directory inside the source code tree, where TypeChef
     * will search for header files.
     * 
     * @param sourceIncludeDir The include directory, relative to the source code tree root.
     */
    public void addSourceIncludeDir(File sourceIncludeDir) {
        sourceIncludeDirs.add(sourceIncludeDir);
    }
    
    /**
     * Adds the default include directories for a Linux source tree. This should
     * work on recent Linux versions.
     * 
     * @param arch The architecture to set the include directories for.
     */
    public void addDefaultLinuxIncludeDirs(String arch) {
        addSourceIncludeDir(new File("include"));
        addSourceIncludeDir(new File("arch/" + arch + "/include"));
        addSourceIncludeDir(new File("arch/" + arch + "/include/generated"));
        addSourceIncludeDir(new File("arch/" + arch + "/include/uapi"));
        addSourceIncludeDir(new File("arch/" + arch + "/include/generated/uapi"));
        addSourceIncludeDir(new File("arch/" + arch + "/include/asm/mach-default"));
        addSourceIncludeDir(new File("arch/" + arch + "/include/asm/mach-generic"));
        addSourceIncludeDir(new File("arch/" + arch + "/include/asm/mach-voyager"));
        addSourceIncludeDir(new File("include/uapi"));
    }
    
    /**
     * Clears the list of include directories in the source code tree.
     */
    public void clearSourceIncludeDirs() {
        sourceIncludeDirs.clear();
    }
    
    public void addPreprocessorDefine(String symbol) {
        preprocessorDefines.add(symbol);
    }
    
    public void clearPreprocessorDefines() {
        preprocessorDefines.clear();
    }
    
//    public void setKbuildParamFile(KbuildParamFile kbuilbParamFile) {
//        this.kbuildParamFile = kbuilbParamFile;
//    }
    
    public void setDimacsModel(File dimacsModel) {
        this.dimacsModel = dimacsModel;
    }
    
//    /**
//     * Sets the output destination. A zip file with the given name will be created.
//     * If the archive already exists, then the .pi files within will be reused and
//     * new ones will be added to the archive.
//     * 
//     * @param output The name of the zip file to store output in. Should end with ".zip".
//     */
//    public void setOutput(File output) {
//        this.output = new ZipArchive(output);
//    }
//    
//    /**
//     * @return The {@link ZipArchive} where the output is stored.
//     */
//    public ZipArchive getOutput() {
//        return output;
//    }
    
//    /**
//     * @param workingDir The working directory where temporary files are stored
//     *      while running TypeChef.
//     */
//    public void setWorkingDir(File workingDir) {
//        this.workingDir = workingDir;
//    }
    
    /**
     * Checks whether all parameters are set to sane values.
     * 
     * @throws IllegalArgumentException If any of the parameters is not set correctly.
     */
    private void checkParameters() throws IllegalArgumentException {
        if (sourceDir == null || !sourceDir.isDirectory()) {
            throw new IllegalArgumentException("Source directory \"" + sourceDir + "\" is not a directory.");
        }
        if (!sourceDir.canRead()) {
            throw new IllegalArgumentException("Source directory \"" + sourceDir + "\" is not readable.");
        }
        
        if (platformHeader == null || !platformHeader.isFile()) {
            throw new IllegalArgumentException("Platform header \"" + platformHeader + "\" does not exist");
        }
        if (!platformHeader.canRead()) {
            throw new IllegalArgumentException("Platform header \"" + platformHeader + "\" is not readable");
        }
        
        if (openVariablesFile != null) {
            if (!openVariablesFile.isFile()) {
                throw new IllegalArgumentException("openFeatures file not specified");
            }
            if (!openVariablesFile.canRead()) {
                throw new IllegalArgumentException("openFeatures file can not be read");
            }
        } else {
            LOGGER.logWarning("No openVariablesFile specified");
        }
        
        if (systemRoot == null || !systemRoot.isDirectory()) {
            throw new IllegalArgumentException("System root \"" + systemRoot + "\" is not a directory.");
        }
        
        if (staticIncludes.isEmpty()) {
            LOGGER.logWarning("No static includes defined");
        }
        for (File staticInclude : staticIncludes) {
            if (staticInclude == null || !staticInclude.isFile()) {
                throw new IllegalArgumentException("Static include header \"" + staticInclude + "\" does not exist");
            }
            if (!staticInclude.canRead()) {
                throw new IllegalArgumentException("Static include header \"" + staticInclude + "\" is not readable");
            }
        }
        
        if (postIncludeDirs.isEmpty()) {
            LOGGER.logWarning("No post include directories specified");
        }
        for (File postIncludeDir : postIncludeDirs) {
            postIncludeDir = new File(systemRoot, postIncludeDir.getPath());
            if (!postIncludeDir.isDirectory()) {
                LOGGER.logWarning("Post include directory \"" + postIncludeDir + "\" is not a directory");
            }
        }
        
        if (sourceIncludeDirs.isEmpty()) {
            LOGGER.logWarning("No source include directories specified");
        }
        for (File sourceIncludeDir : sourceIncludeDirs) {
            sourceIncludeDir = new File(sourceDir, sourceIncludeDir.getPath());
            if (!sourceIncludeDir.isDirectory()) {
//                Logger.INSTANCE.logWarning("Source include directory \"" + sourceIncludeDir + "\" is not a directory");
            }
        }
        
        // TODO: preprocessorDefines
        
//        if (kbuildParamFile == null) {
//            LOGGER.logWarning("No kbuildParamFile specified");
//        }
        
        if (dimacsModel != null) {
            if (!dimacsModel.isFile()) {
                throw new IllegalArgumentException("dimacsModel \"" + dimacsModel + "\" does not exist");
            }
            if (!dimacsModel.canRead()) {
                throw new IllegalArgumentException("dimacsModel \"" + dimacsModel + "\" is not readable");
            }
        } else {
            LOGGER.logWarning("No DIMACS model specified");
        }
        
//        if (output == null) {
//            throw new IllegalArgumentException("Output archive not specified.");
//        }
        
//        if (workingDir == null || !workingDir.isDirectory()) {
//            throw new IllegalArgumentException("Working directory \"" + workingDir + "\" is not a directory.");
//        }
//        if (!workingDir.canWrite()) {
//            throw new IllegalArgumentException("Source directory \"" + sourceDir + "\" is not writable.");
//        }
    }
    
    
    private List<String> buildParameters(File file) {
        List<String> params = new ArrayList<>();
        
        // environment stuff
        params.add("--platfromHeader=" + platformHeader.getAbsolutePath());
        params.add("--systemRoot=" + systemRoot.getAbsolutePath());
        
        // typechef behavior
        params.add("--lex");
        params.add("--lexNoStdout");
        params.add("--no-analysis");
        

        // Kconfig variables
        params.add("--prefixonly=CONFIG_");
        if (openVariablesFile != null) {
            params.add("--openFeat=" + openVariablesFile.getAbsolutePath());
        }
        
        // output
//        params.add("--output=" + piOutput.getAbsolutePath().substring(0, piOutput.getAbsolutePath().length() - 3));
//        params.add("--lexOutput=" + piOutput.getAbsolutePath());
        
        // presence condition of file TODO: is this even used?
//        if (file.getPresenceCondition() != null) {
//            try {
//                BufferedWriter writer = new BufferedWriter(new FileWriter(pcFile));
//                writer.write(file.getPresenceCondition().toString()); // TODO: format
//                writer.newLine();
//                writer.close();
//                
//                params.add("--filePC=" + pcFile.getAbsolutePath());
//            } catch (IOException e) {
//                Logger.INSTANCE.logException("Can't write presence condition file", e);
//            }
//            
//        }
        
        // include stuff
        for (File staticInclude : staticIncludes) {
            params.add("--include=" + staticInclude.getAbsolutePath());
        }
        for (File sourceIncludeDir : sourceIncludeDirs) {
            params.add("--incdir=" + new File(sourceDir, sourceIncludeDir.getPath()).getAbsolutePath());
        }
        for (File postIncludeDir : postIncludeDirs) {
            params.add("--postIncludes=" + postIncludeDir.getPath());
        }
        
        // preprocessor definitions
        for (String symbol : preprocessorDefines) {
            params.add("-D" + symbol);
        }
        
        // kbuildParamFile
//        if (kbuildParamFile != null) {
//            kbuildParamFile.setSourceDir(sourceDir);
//            params.addAll(kbuildParamFile.getExtraParameters(file));
//        }
        
        // the source file to parse
        params.add(new File(sourceDir, file.getPath()).getAbsolutePath());
        
        return params;
    }
    
    /**
     * Runs a TypeChef process with the current configuration and the given output files.
     * 
     * @param file The source file in the source code tree to run TypeChef on.
     * @return The process' exit status.
     * 
     * @throws IOException If running the process fails.
     * @throws IllegalArgumentException If any of the parameters of the current configuration is not set correctly.
     */
    private void runTypeChef(final File file) throws IOException, IllegalArgumentException {
        final List<String> params = buildParameters(file);
        
        
        if (LOG_CALL_PARAMS) {
            LOGGER.logDebug(params.toArray(new String[0]));
        }
        
        final ServerSocket serSock = new ServerSocket(0);
        final List<String> errors = new LinkedList<>();
        
        Thread comm = new Thread("Comm of " + Thread.currentThread().getName()) {
            
            @SuppressWarnings("unchecked")
            public void run() {
                try {
                    Socket socket = serSock.accept();
                    
                    ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());
                    ObjectInputStream in = new ObjectInputStream(socket.getInputStream());
                    
                    out.writeObject(params);
                    
                    Object result = in.readObject();
                    if (result != null) {
                        System.out.println("Result:\n" + result.toString());
                    }
                    
                    Object errorList = in.readObject();
                    if (errorList != null) {
                        errors.addAll((List<String>) errorList);
                    }
                    
                    serSock.close();
                } catch (EOFException e) {
                    LOGGER.logWarning("TypeChefRunner exited without sending a result");
                } catch (ClassNotFoundException | IOException e) {
                    LOGGER.logException("Exception", e);
                }
            };
            
        };
        comm.start();
        
        if (CALL_IN_SAME_VM) {
            LOGGER.logWarning("Starting TypeChef in same JVM");
            try {
                TypeChefRunner.main(new String[] {String.valueOf(serSock.getLocalPort())});
            } catch (Exception e) {
                LOGGER.logException("Exception in TypeChefRunner", e);
            }
        } else {
            ProcessBuilder builder = new ProcessBuilder("java",
                    "-Xmx20g",
                    "-cp", System.getProperty("java.class.path"),
                    TypeChefRunner.class.getName(),
                    String.valueOf(serSock.getLocalPort()));
            if (INHERIT_OUTPUT) {
                builder.redirectError(Redirect.INHERIT);
                builder.redirectOutput(Redirect.INHERIT);
            }
            Process process = builder.start();
            
            try {
                process.waitFor();
            } catch (InterruptedException e) {
                LOGGER.logException("Exception while waiting", e);
            }
        }
        
        try {
            comm.join();
        } catch (InterruptedException e) {
            LOGGER.logException("Exception while waiting", e);
        }
        
        if (!errors.isEmpty()) {
            String[] errorStr = new String[errors.size() + 1];
            errorStr[0] = "Lexer errors:";
            for (int i = 1; i < errorStr.length; i++) {
                errorStr[i] = errors.get(i - 1);
            }
            LOGGER.logInfo(errorStr);
        }
        
    }
    
    public SourceFile runOnFile(File file) {
        LOGGER.logDebug("Checking parameters");
        checkParameters();
        
        SourceFile result = new SourceFile(file);
        
        try {
            runTypeChef(file);
        } catch (IllegalArgumentException e) {
            LOGGER.logException("Invalid typechef configuration", e);
        } catch (IOException e) {
            LOGGER.logException("Error running typechef", e);
        }
        
        return result;
    }
    
}
